import groovy.transform.Field

def one_param_opcode(Closure gen_statement) {
    (0..7).collect { c ->
        """
        new Code() {
            @Override
            void execute(UM um) { ${gen_statement(c)} }
        }"""
    }.join(",\n")
}

def two_param_opcode(Closure gen_statement) {
    (0..63).collect { bc ->
        """
        new Code() {
            @Override
            void execute(UM um) { ${gen_statement(bc >>> 3, bc & 7)} }
        }"""
    }.join(",\n")
}

def three_param_opcode(Closure gen_statement) {
    (0..511).collect { abc ->
        """
        new Code() {
            @Override
            void execute(UM um) { ${gen_statement(abc >>> 6, (abc >>> 3) & 7, abc & 7)} }
        }"""
    }.join(",\n")
}

@Field
Integer ORTHOGRAPHY_VALUE_LIMIT = 32

def gen_orthography(a) {
    (0..<ORTHOGRAPHY_VALUE_LIMIT).collect { c ->
        """
        new Code() {
            @Override
            void execute(UM um) { um.r$a = $c; }
        }"""
    }.join(",\n")
}


new File("org/ifcx/ifcp/CodeFactory.java").write """
// Generated by generate_java_code.groovy on ${new Date()}

package org.ifcx.ifcp;

public class CodeFactory {
    static final int ORTHOGRAPHY_VALUE_LIMIT = $ORTHOGRAPHY_VALUE_LIMIT;

    static Code[] conditional_move = {
        ${three_param_opcode { a, b, c -> "if (um.r$c != 0) um.r$a = um.r$b;" } }
    };
    static Code[] array_index = {
        ${three_param_opcode { a, b, c -> "um.r$a = um.arrays.get(um.r$b)[um.r$c];" } }
    };
    static Code[] array_amend = {
        ${three_param_opcode { a, b, c -> "um.arrays.get(um.r$a)[um.r$b] = um.r$c;" } }
    };
    static Code[] addition = {
        ${three_param_opcode { a, b, c -> "um.r$a = um.r$b + um.r$c;" } }
    };
    static Code[] multiplication = {
        ${three_param_opcode { a, b, c -> "um.r$a = (int) ((((long) um.r$b) & 0xFFFFFFFFL) * (((long) um.r$c) & 0xFFFFFFFFL));" } }
    };
    static Code[] division = {
        ${three_param_opcode { a, b, c -> "um.r$a = (int) ((((long) um.r$b) & 0xFFFFFFFFL) / (((long) um.r$c) & 0xFFFFFFFFL));" } }
    };
    static Code[] not_and = {
        ${three_param_opcode { a, b, c -> "um.r$a = ~(um.r$b & um.r$c);" } }
    };

    static Code[] allocation = {
        ${two_param_opcode { b, c -> "um.r$b = um.allocate(um.r$c);" } }
    };
    static Code[] abandonment = {
        ${one_param_opcode { c -> "um.deallocate(um.r$c);" } }
    };

    static Code[] output = {
        ${one_param_opcode { c -> "um.output(um.r$c);" } }
    };
    static Code[] input = {
        ${one_param_opcode { c -> "um.r$c = um.input();" } }
    };

    static Code[] load = {
        ${two_param_opcode { b, c -> "um.load(um.r$b); um.ip = um.r$c; " } }
    };

    static Code halt = new Code() {
        @Override
        void execute(UM um) { um.halt(); }
    };

    static Code illegal = new Code() {
        @Override
        void execute(UM um) { um.illegal(); }
    };

    static Code[][] orthography = {
        { ${ (0..7).collect {  gen_orthography(it) }.join("},\n{")} }
    };

    public static Code forOp(int op) {
        switch (op >>> 28) {
            case 0 : // Conditional Move
                return conditional_move[op & 511];
            case 1 : // Array Index
                return array_index[op & 511];
            case 2 : // Array Amend
                return array_amend[op & 511];
            case 3 : // Addition
                return addition[op & 511];
            case 4 : // Multiplication
                return multiplication[op & 511];
            case 5 : // Division
                return division[op & 511];
            case 6 : // Not-And
                return not_and[op & 511];
            case 7 : // Halt
                return halt;
            case 8 : // Allocation
                return allocation[op & 63];
            case 9 : // Abandonment
                return abandonment[op & 7];
            case 10 : // Output
                return output[op & 7];
            case 11 : // Input
                return input[op & 7];
            case 12 : // Load Program
                return load[op & 63];
            case 13 : // Orthography
                final int v = op & 0x1FFFFFF;
                final int a = (op >> 25) & 7;
                if (v < ORTHOGRAPHY_VALUE_LIMIT) {
                    return orthography[a][v];
                }
                return new Code() {
                    @Override
                    void execute(UM um) { um.setRegister(a, v); }
                };
            default:
                return illegal;
        }
    }
}
"""
